#!/bin/bash
set -e

SCRIPT_PATH=$( cd $(dirname $0) ; pwd -P )

source ${SCRIPT_PATH}/set-aws-profile
source ${SCRIPT_PATH}/_common-functions.bash

GRADLE_MODULE_ROOT=${SCRIPT_PATH}/..
REVISIONS_DIR=${GRADLE_MODULE_ROOT}/build/revisions
CREATE_REVISION_TASK_NAME_PREFIX=createRevision

CMD=$1

function bucket_name {
    ALIAS=$(aws iam list-account-aliases --query 'AccountAliases[0]' --output text)
    echo "codedeploy-$ALIAS"
}

function physical_resource_id {
    echo $(aws cloudformation list-stack-resources \
            --stack-name $1 \
            --query "StackResourceSummaries[?ResourceType==\`$2\`].PhysicalResourceId" \
            --output text)
}

function read_output_value {
    echo $(aws cloudformation describe-stacks \
            --stack-name $1 \
            --query "Stacks[*].Outputs[?OutputKey==\`$2\`].OutputValue" \
            --output text)
}

case "$CMD" in
        create-codedeploy-bucket)
            BUCKET=$(bucket_name)
            aws s3 mb s3://${BUCKET}
            aws s3api put-bucket-versioning --bucket ${BUCKET} \
                --versioning-configuration Status=Enabled
            ;;

        push)
            STACK=$2
            DEPLOYABLE_NAME=$3

            echo -e "*\n* Creating CodeDeploy revisions\n*"

            if [[ -z ${DEPLOYABLE_NAME} ]]; then
                echo "Using deployable name: ${STACK}"
                DEPLOYABLE_NAME=${STACK}
            fi

            # https://unix.stackexchange.com/a/13474
            function upsearch () {
              slashes=${SCRIPT_PATH//[^\/]/}
              directory="${SCRIPT_PATH}"
              for (( n=${#slashes}; n>0; --n ))
              do
                test -e "$directory/$1" && echo "$directory/$1" && return
                directory="$directory/.."
              done
            }

            GRADLEW=$(upsearch gradlew)
            if [[ ! -e ${GRADLEW} ]]; then
                echo "Gradle wrapper not found"
                exit 1
            fi

            ${GRADLEW} -p $(dirname ${GRADLEW}) candyRunTask "-PcandyTaskName=${CREATE_REVISION_TASK_NAME_PREFIX}-${DEPLOYABLE_NAME}"

            REVISION_DIR=${REVISIONS_DIR}/${DEPLOYABLE_NAME}

            $0 docker-tag-and-push ${REVISION_DIR}

            $0 codedeploy-push-and-wait ${STACK} ${REVISION_DIR}
            ;;

        docker-tag-and-push-all)
            for REVISION_DIR in ${REVISIONS_DIR}/*; do
                $0 docker-tag-and-push ${REVISION_DIR}
            done
            ;;

        docker-tag-and-push)
            REVISION_DIR=$2
            REVISION_DIR_RELATIVE=$(realpath --relative-to=`pwd` ${REVISION_DIR})

            source ${REVISION_DIR}/compose.env

            for SERVICE in "${SERVICES[@]}"; do

                echo -e "*\n* Tagging and pushing ${SERVICE} docker image for ${REVISION_DIR_RELATIVE}\n*"

                IMAGE_ID="${SERVICE}_IMAGE_ID"
                IMAGE_TAG="${SERVICE}_IMAGE_TAG"
                ECR_STACK_NAME="${SERVICE}_ECR_STACK_NAME"

                TARGET_IMAGE=$(read_output_value ${!ECR_STACK_NAME} ImageURI)

                docker tag ${!IMAGE_ID} ${TARGET_IMAGE}:${!IMAGE_TAG}

                docker_login_ecr

                docker push ${TARGET_IMAGE}:${!IMAGE_TAG}

                echo -e \
                    "\n# Overridden by $0 \
                     \n${SERVICE}_IMAGE=${TARGET_IMAGE}:${!IMAGE_TAG}" >> ${REVISION_DIR}/compose.env
            done
            ;;

        codedeploy-push-and-wait)
            AUTO_SCALING=false
            if [[ $2 == "--auto-scaling" ]]; then
                AUTO_SCALING=true
                shift 1
            fi

            STACK=$2
            REVISION_DIR=$3
            REVISION_DIR_RELATIVE=$(realpath --relative-to=`pwd` ${REVISION_DIR})

            STACK_CMD="${SCRIPT_PATH}/stack"

            if ${AUTO_SCALING}; then
                ORIGINAL_CAPACITY=$(${STACK_CMD} get-desired-capacity ${STACK})

                if [[ ${ORIGINAL_CAPACITY} -lt 2 ]]; then
                   echo -e "*\n* Desired capacity of ${STACK} ASG is ${ORIGINAL_CAPACITY}, temporarily making it 2\n*"

                   ${STACK_CMD} set-desired-capacity ${STACK} 2
                   timeout 900 ${STACK_CMD} wait-for-elb-instances ${STACK}
                fi
            fi

            echo -e "*\n* Pushing ${REVISION_DIR_RELATIVE} to S3 and initiating CodeDeploy deployment to ${STACK}\n*"

            DEPLOYMENT_ID=`eval $($0 codedeploy-push ${STACK} ${REVISION_DIR}) --output text`

            $0 wait ${DEPLOYMENT_ID}

            if ${AUTO_SCALING}; then
                echo Changing desired capacity of ${STACK} ASG back to ${ORIGINAL_CAPACITY}

                ${STACK_CMD} set-desired-capacity ${STACK} ${ORIGINAL_CAPACITY}
            fi
            ;;

        codedeploy-push)
            STACK=$2
            REVISION_DIR=$3

            APP_NAME=$(physical_resource_id ${STACK} AWS::CodeDeploy::Application)

            CREATE_DEPLOYMENT=$(aws deploy push --application-name ${APP_NAME} \
                --s3-location s3://$(bucket_name)/${STACK}.zip \
                --source ${REVISION_DIR} \
                | tail -n 1)

            DG_NAME=$(physical_resource_id ${STACK} AWS::CodeDeploy::DeploymentGroup)
            DC_NAME=$(physical_resource_id ${STACK} AWS::CodeDeploy::DeploymentConfig)

            if [[ -z ${DC_NAME}  ]]; then
                DC_NAME="CodeDeployDefault.OneAtATime"
            fi

            DG_NAME_TEMPLATE="<deployment-group-name>"
            DC_NAME_TEMPLATE="<deployment-config-name>"
            DESCRIPTION_TEMPLATE="<description>"

            CREATE_DEPLOYMENT=${CREATE_DEPLOYMENT/${DG_NAME_TEMPLATE}/${DG_NAME}}
            CREATE_DEPLOYMENT=${CREATE_DEPLOYMENT/${DC_NAME_TEMPLATE}/${DC_NAME}}
            CREATE_DEPLOYMENT=${CREATE_DEPLOYMENT/${DESCRIPTION_TEMPLATE}/\'Deploy after push\'}

            echo ${CREATE_DEPLOYMENT} \
                --auto-rollback-configuration enabled=true,events=DEPLOYMENT_FAILURE \
                --ignore-application-stop-failures
            ;;

        status)
            aws deploy get-deployment --deployment-id $2 --query 'deploymentInfo.status'
            ;;

        wait)
            DEPLOYMENT_ID=$2
            STACK=$(aws deploy get-deployment \
                          --deployment-id ${DEPLOYMENT_ID} \
                          --query=deploymentInfo.applicationName \
                          --output text \
                          | awk -F-MyApplication- '{print $1}')

            printf "$(date +%H:%M:%S) ${STACK} deployment \"${DEPLOYMENT_ID}\"\n"

            PREV_STATUS=
            while true
            do
                set +e
                STATUS=`$0 status ${DEPLOYMENT_ID}`
                set -e
                STATUS_LINE="$(date +%H:%M:%S) ${STACK} deployment ${STATUS}"

                if [[ -t 1 ]] && ( [[ -z ${PREV_STATUS} ]] || [[ ${PREV_STATUS} == ${STATUS} ]] ); then
                    printf "\r${STATUS_LINE}"
                else
                    printf "\n${STATUS_LINE}"
                fi

                if [[ ${STATUS} == '"Succeeded"' ]]; then
                    echo
                    exit 0
                fi

                if [[ ${STATUS} == '"Failed"' ]]; then
                    echo
                    exit 1
                fi

                if [[ ${STATUS} == '"Stopped"' ]]; then
                    echo
                    exit 1
                fi

                PREV_STATUS=${STATUS}

                sleep 1
            done
            ;;

        *)
            echo $"Usage: $0 <command> <args>

  $0 codedeploy-push <stack-name> <revision-dir>
  $0 codedeploy-push-and-wait [--auto-scaling] <stack-name> <revision-dir>
  $0 create-codedeploy-bucket
  $0 docker-tag-and-push <revision-dir>
  $0 docker-tag-and-push-all
  $0 push <stack-name> [<deployable-name>]
  $0 status <deployment-id>
  $0 wait <deployment-id>"

            exit 1
            ;;
esac
